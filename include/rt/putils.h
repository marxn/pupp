#ifndef _PUPP_UTILS_H_
#define _PUPP_UTILS_H_

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>
#include <string>
#include <iostream>
#include <errno.h>
#include <poll.h>
#include <signal.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <queue>
#include <map>
#include <iostream>

using namespace std;

class PThread
{
    public:
        PThread():isDetach(false), Interruptted(false), Started(false)
        {
            pthread_mutex_init(&this->StartMutex, NULL);
            pthread_cond_init(&this->StartCond, NULL);
        }
        
        virtual ~PThread()
        {
            pthread_mutex_destroy(&this->StartMutex);
            pthread_cond_destroy(&this->StartCond);
        }
        virtual void run() = 0;

        bool Start()
        {
            if(pthread_create(&this->tid, NULL, ThreadWrapper, this) == 0)
            {
                //we setup a simple barrier to ensure the initialization has been done by the starting thread.
                pthread_mutex_lock(&this->StartMutex);
                while(this->Started == false)
                {
                    pthread_cond_wait(&this->StartCond, &this->StartMutex);
                }
                pthread_mutex_unlock(&this->StartMutex);
                
                return true;
            }
            return false;
        }
        bool StartAndDetach()
        {
            bool rtn = false;
            
            pthread_attr_t attr;
            isDetach = true;
            
            pthread_attr_init(&attr);
            pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
            
            if(pthread_create(&this->tid, &attr, ThreadWrapper, this) == 0)
            {
                //we setup a simple barrier to ensure the initialization has been done by the starting thread.
                pthread_mutex_lock(&this->StartMutex);
                
                while(this->Started == false)
                {
                    pthread_cond_wait(&this->StartCond, &this->StartMutex);
                }
                
                pthread_mutex_unlock(&this->StartMutex);
                rtn = true;
            }
            
            pthread_attr_destroy(&attr);
            
            return rtn;
        }
        bool Interrupt()
        {
            pthread_kill(this->tid, SIGUSR1);
        }
        void Wait()
        {
            pthread_join(this->tid, NULL);
        }
        bool TryWait()
        {
            if(pthread_tryjoin_np(this->tid, NULL) == 0)
            {
                return true;
            }
            return false;
        }
    private:
        pthread_t tid;
        bool isDetach;
        
        pthread_mutex_t StartMutex;
        pthread_cond_t StartCond;
        
        static void SigHandler(int x)
        {
            self->Interruptted = true;
        }
        
        static void * ThreadWrapper(void * arg)
        {
            PThread * theThread = (PThread *)arg;
            
            //initialize TLS variable. this must be done because
            //some kind of glibc use lazy-allocation of TLS that
            //may crash in async-signal-case.
            theThread->self = theThread;
            
            //Disable useless signal.
            //SIGPIPE may be generated by writing to a closed socket.
            signal(SIGPIPE, SIG_IGN);
            
            //Disable reserved signal catching.
            DisableSignalCatch();
            
            //send a signal to tell the caller that all the init work
            //is done.
            //note: the mutex must be locked before we change the 
            //      value of theThread->Started.
            pthread_mutex_lock(&theThread->StartMutex);
            theThread->Started = true;
            pthread_mutex_unlock(&theThread->StartMutex);
            pthread_cond_signal(&theThread->StartCond);
            
            //go to thread function.
            theThread->run();
        }
        
    protected:
        //PThread uses SIGUSR1 for event notification.
        //Note: all threads derived from PThread must check EINTR 
        //after system call if EnableSignalCatch() invoked.
        static bool EnableSignalCatch()
        {
            struct sigaction act, oact;
            act.sa_handler = SigHandler;
            sigemptyset(&act.sa_mask);
            act.sa_flags = 0;
            act.sa_flags |= SA_INTERRUPT;
            if(sigaction(SIGUSR1, &act, &oact) < 0)
            {
                return false;
            }
            return true;
        }
        static bool DisableSignalCatch()
        {
            struct sigaction act, oact;
            act.sa_handler = SigHandler;
            sigemptyset(&act.sa_mask);
            act.sa_flags = 0;
            act.sa_flags |= SA_RESTART;
            if(sigaction(SIGUSR1, &act, &oact) < 0)
            {
                return false;
            }
            return true;
        }
        
        bool Interruptted;
        bool Started;
        //use TLS variable to save self pointer used by signal handler.
        static __thread PThread * self;
};

__thread PThread * PThread::self = NULL;

class PThreadPool
{
    public:
        PThreadPool():MaxSize(10),CurrentSize(0)
        {
            pthread_mutex_init(&this->PoolMutex, NULL);
            pthread_cond_init(&this->PoolCond, NULL);
        }
        PThreadPool(int max_size):MaxSize(max_size),CurrentSize(0)
        {
            pthread_mutex_init(&this->PoolMutex, NULL);
            pthread_cond_init(&this->PoolCond, NULL);
        }
        virtual ~PThreadPool()
        {
            pthread_mutex_destroy(&this->PoolMutex);
            pthread_cond_destroy(&this->PoolCond);
        }
        void SetPoolMaxSize(int size)
        {
            this->MaxSize = size;
        }
        PThread * GetPThread()
        {
            PThread * result(NULL);
            pthread_mutex_lock(&PoolMutex);
            
            if(this->CurrentSize < this->MaxSize)
            {
                PThread * newthread = this->CreatePThread();
                if(newthread)
                {
                    result = newthread;
                    this->CurrentSize++;
                }
            }
                
            pthread_mutex_unlock(&PoolMutex);
            return result;
        }
        PThread * WaitPThread()
        {
            PThread * result(NULL);
            pthread_mutex_lock(&this->PoolMutex);
            
            while(this->CurrentSize >= this->MaxSize)
                    pthread_cond_wait(&this->PoolCond, &this->PoolMutex);
                    
            PThread * newthread = this->CreatePThread();
            if(newthread)
            {
                result = newthread;
                this->CurrentSize++;
            }
                
            pthread_mutex_unlock(&this->PoolMutex);
            return result;
        }
        void Recycle(PThread * thread)
        {
            delete thread;
            pthread_mutex_lock(&this->PoolMutex);
            this->CurrentSize--;
            pthread_mutex_unlock(&this->PoolMutex);
            pthread_cond_signal(&this->PoolCond);
        }
        void WaitForAllRecycled()
        {
            pthread_mutex_lock(&this->PoolMutex);
            while(this->CurrentSize != 0)
                pthread_cond_wait(&this->PoolCond, &this->PoolMutex);
            pthread_mutex_unlock(&this->PoolMutex);
        }
        int GetCurrentSize()
        {
            return this->CurrentSize;
        }
    protected:
        virtual PThread * CreatePThread() = 0;
    private:
        pthread_mutex_t PoolMutex;
        pthread_cond_t PoolCond;
        int MaxSize;
        int CurrentSize;
        
};

class PoolThread: public PThread
{
    public:
        PoolThread(PThreadPool * pool)
        {
            this->ThreadPool = pool;
        }
        void run()
        {
            do_it();
            this->ThreadPool->Recycle(this);
        }
        virtual void do_it() = 0;
    private:
        PThreadPool * ThreadPool;
};

class PuppConfig
{
    public:
        PuppConfig()
        {
            pthread_mutex_init(&this->AccessMutex, NULL);
        }
        ~PuppConfig()
        {
            pthread_mutex_destroy(&this->AccessMutex);
        }
        bool LoadConfigFile(string filename)
        {
            pthread_mutex_lock(&this->AccessMutex);
            FILE * fp = fopen(filename.c_str(), "r");
            if(fp==NULL)
            {
                pthread_mutex_unlock(&this->AccessMutex);
                return false;
            }
            
            this->store.clear();
            while(!feof(fp))
            {
                char buf[1024];
                bzero(buf, sizeof(buf));
                
                fgets(buf, sizeof(buf), fp);
                char * line = buf;
                char * saveptr = NULL;
                char * key = NULL;
                char * value = NULL;
            
                while(isspace(*line))
                    line++;
                    
                if(*line == '#')
                    continue;
                    
                key = strtok_r(line, "=\r\n\t", &saveptr);
                line = saveptr;
                value = strtok_r(line, "=\r\n\t", &saveptr);
                
                if(key == NULL || value == NULL)
                    continue;
                
                key   = Trim(key);
                value = Trim(value);
                this->store[key] = value;
            }
            fclose(fp);
            pthread_mutex_unlock(&this->AccessMutex);
            return true;
        }
        string GetConfValue(string key)
        {
            pthread_mutex_unlock(&this->AccessMutex);
            string result = store[key];
            pthread_mutex_unlock(&this->AccessMutex);
            return result;
        }
    private:
        pthread_mutex_t AccessMutex;
        map<string, string> store;
        
        char * Trim(char * str)
        {
            char * result = str;
            int i = 0;
            while(*str == ' ')
                str++;
            if(*str == '\"') 
                str++;

            result = str;

            if(*str!='\0')
                str += strlen(str) - 1;
            else
                return result;

            while(*str == ' ')
                str--;

            if(*str == '\"')
                *str = '\0';
            else
                str[1] = '\0';

            return result;
        }
};

#endif

